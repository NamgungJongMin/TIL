# 전역변수 사용의 문제점

## 1) 변수의 생명주기

```
function foo(){
  var x = 'local';
  console.log(x);
  return x;
}

foo();
console.log(x); //output : ReferenceError
```

### 1.1) 예외

### 결론

## 2) 전역변수

### 2.1) 전역변수의 문제점

1. 암묵적 결합

2. 긴 생명주기

3. 스코프 체인 상에서 종점에 존재

4. 네임스페이스 오염

### 2.2) 전역변수 사용 억제하는 방법

1. 즉시 실행 함수

2. 네임스페이스 객체

```
var MYAPP ={};

MYAPP.name = 'lee';

console.log(MYAPP.name); //output: 'lee'
```

3. 모듈 패턴
4. ES6 모듈

---

# 수업

모듈이라는 것을 사용하게 되면, 전역변수를 쓸래야 쓸 수가 없음.

지금 전역 스코프는 두개가 있는거야.
es5까지는 전역 스코프라는 것이 window였음.
es6부터는 let const로 선언한 전역 변수는 다른곳에, window는 window대로 저장됨 따로.

윈도우객체 + 렉시컬환경 = 전역 스코프

결국 3개 중에 어떤 변수를 선택할 것이냐.

const는 상수다? 조심해야할 표현.
const로 객체를 선언하면 불변이 아님.

const a = 1; 상수
const o = {}; 상수가 아니다.
상수처럼 쓰고싶으면 얼려야된다. object.freeze();

우리가 꼭 그렇게 써야한다는게 아니라 그렇게 쓰자는 의견의 움직임이 있다.

const는 재 할당을 금지하는 것.

---

# 프로퍼티 어트리뷰트

프로퍼티또한 값 => 객체다
프로퍼티가 또 프로퍼티를 가질 수 있다.

그렇게 해서 가지는 프로퍼티의 프로퍼티가 [[Value]], [[Writable]], [[Enumerable]], [[Configurable]] 등 임.

즉 프로퍼티 어트리뷰트란 프로퍼티를 설명하는 프로퍼티의 프로퍼티라고 보면 됩니다!.

내부슬롯과 내부메서드에 대해 알아야만 하나 고민을 하셨는데, [[prototype]] 모든 객체는 요 내부슬롯을 갖는데, 여기서 내부 슬롯에 대한 내용을 이해시키기 위해 설명해 놓으신 부분.

인간 인식에 대한 철학적 사고를 프로그래밍으로 옮겨온 것이 프로퍼티. 1000개의 속성을 다 나열해야만 대상이냐. 아니다. 관심이 있는 속성에 대해만 나열해도 대상이라고 인식한다. - 프로그래밍 추상화.

enumerable / iterable

열거 / 순회

열거는 순서와 관계없이 객체: 키값

순회는 순서와 관계있이 배열: 인덱스값

## 생성자 함수에 대한 객체 생성

객체 리터럴 : 런타임에 바로 객체를 만들 수 있는 형식

- 직관적이고 편함. 몇개 안되는 객체를 생성할 때 좋음.

생성자 함수 사용 : 중복된 코드(메서드)를 지닌 객체를 여러개 생성할 때 좋아요. 함수에서 재사용성에 대해서도 좋음.

객체 리터럴 경우 유지보수성 떨어짐 100개 만들었을 때 함수 고치려면 100개 고쳐야됨.

생성자 함수는 함수만 고쳐주면 100개에 적용!

--> 2개 3개 요것 정도면 리터럴로 할만하지 않을까?
nono

여러개의 , 중복된 코드 가진, 객체 만들 땐 생성자 함수를 사용하자 -> 코드 일관성.

> this는 일단 외워라. 객체 리터럴 내부의 this는 메서드를 호출한 객체. 생성자 함수 내부의 this는 생성자 함수가 생성할 instance 객체. 메서드 내부의 this는 점(.) 앞

함수 반환 값이 없으면 암묵적으로 undefined 반환

생성자 함수
암묵적인 처리 3개

1. 빈객체 만든다
2. this 바인딩

- 우리가 this에다가 값을 할당해줄 수 없다. 문법적으로 막혀있음.

3.

자바스크립트 함수는 호출하는 방식에 따라서 어떤 함순지 정의함.

생성자 함수. new를 붙인다는 가정에 짠 코든데 new를 안붙여도 에러가 안나!! -> 생성자 함수를 이용한 인스턴스 생성의 단점.

런타임 이전에 생성자 함수가 만들어지면서 프로토타입 객체도 만들어진다!
일반 객체들 말고! 함수 객체들만 프로토타입 프로퍼티를 갖는다.

(필기내용 입력)

```
function foo(){
  console.log(this);
} //무슨함수냐 - 모른다

//일반함수
//[[Call]]
foo(); //undefined

// 생성자함수
// [[Construct]]
new foo(); //{}

console.log(new foo() instanceof foo); // true

const o = {foo};

//메서드
o.foo();

```

우리가 만드는 함수들은 callable이면서 constructor 이다.
생성자 함수로 호출이 안될지언정 constructor 프로퍼티를 만들어버린다.

> 자바스크립트의 부정적인 부분. 왜 그렇게 만들었을까? 그냥 강사님의 예측으로는 애초엔 객체지향을 고려하지 않고 만든 언어에 나중에 객체 지향 프로그래밍을 접목시키고 싶었고, 함수에 기능을 뭉쳐넣어버렸다.

일반함수로는 화살표 함수를 쓰자. 메서드는 메서드 축약표현으로 만들자.

# 함수와 일급객체

결국 함수가 객체다!
일반적인 객체와 동일한 취급을 받는다.!

length caller 안중요함.

arguments 중요

```
const sum = function () {
  // 1,2,3,4
  console.log(arguments);
  // node.js => [arguments] ['0':1, '1':2, '2':3, '3':4]
  // chrome => Arguments(4) [1,2,3,4,callee: f, Symbol(Symbol.iterator): f]
  //return a + b;
}

console.log(sum(1,2,3,4)); // 3
```

인자(매개변수)보다 인수가 많을때, 혹은 인수가 가변적일 때, 비워놓자.
가변인자함수

arguments는 유사배열 객체
index를 키값으로 갖는다.
length가 있다.

## **rest parameter**

프로토타입 막 바꾸고 하는 그런 책에 적힌거 -> 선생님께서 하고싶언던 말. 하지마라 그렇게.
object.creat()써라.

---

1바이트가 왜 8비트

ascii

1바이트가 처음부터 8비트는 아니었고
미국에서 정보교환을 할 때 어떤 방식으로 하는지 ascii
128가지의 정보를 가지고있음.
2\*\*7 7비트면 되는데

1비트를 추가함(정보가 들어왔을때 판단하는 비트)

유럽권까지 포함되었을때 256가지는 필요하다고 여겨서 전체 8비트를 사용하게 되었다.

unicode

처음에는 미국에서 ascii로 사용하다가 다른언어를 사용하고 있는 나라들이 ascii 안에 속해있지 않은 문자를 사용하고 싶어서 unicode가 나옴.

최대 5바이트

---

stack 자료구조

queue 자료구조

linked list 자료구조

만들어보는 수업이 있음 준비해야됨
